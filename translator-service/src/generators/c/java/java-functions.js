import { FunctionDeclaration, ReturnStatement } from '../../../core/ast-nodes.js';

export class JavaFunctionsGenerator {
  constructor() {
    console.log('âœ… C JavaFunctionsGenerator initialized');
  }

  canGenerate(astNode) {
    return astNode.type === 'function_declaration' || 
           astNode.type === 'return_statement' ||
           astNode.type === 'call_expression';
  }

  generate(astNode, context) {
    if (!this.canGenerate(astNode)) {
      console.warn(`JavaFunctionsGenerator cannot generate node type: ${astNode.type}`);
      return '';
    }

    console.log(`JavaFunctionsGenerator processing: ${astNode.type}`);

    switch (astNode.type) {
      case 'function_declaration':
        return this.generateFunctionDeclaration(astNode, context);
      case 'return_statement':
        return this.generateReturnStatement(astNode, context);
      case 'call_expression':
        return this.generateCallExpression(astNode, context);
      default:
        return '';
    }
  }

  generateFunctionDeclaration(astNode, context) {
    // Map Java return types to C types
    const typeMap = {
      'int': 'int',
      'void': 'void',
      'float': 'float',
      'double': 'double',
      'char': 'char',
      'boolean': 'int',
      'String': 'char*',
      'byte': 'char',
      'short': 'short',
      'long': 'long'
    };

    const cReturnType = typeMap[astNode.return_type] || 'int';
    const funcName = astNode.name === 'main' ? 'main' : astNode.name;
    
    // Convert parameters
    const params = astNode.parameters.map(param => {
      const paramType = typeMap[param.type] || 'int';
      return `${paramType} ${param.name}`;
    }).join(', ');

    // Generate function signature
    let funcSignature = `${cReturnType} ${funcName}(${params})`;

    // If main function, add argc/argv
    if (funcName === 'main' && params === '') {
      funcSignature = 'int main(int argc, char* argv[])';
    }

    // Generate body
    const body = this.generateFunctionBody(astNode.body, context);

    return `${funcSignature} {\n${body}\n}`;
  }

  generateFunctionBody(bodyStatements, context) {
    if (!bodyStatements || bodyStatements.length === 0) {
      return '    // Empty function body';
    }

    let bodyCode = '';
    
    // Set context for the function
    if (context && context.setCurrentFunction) {
      context.setCurrentFunction('function');
    }

    bodyStatements.forEach(statement => {
      // In a real implementation, you would dispatch to appropriate generators
      bodyCode += `    ${statement};\n`;
    });

    return bodyCode;
  }

  generateReturnStatement(astNode, context) {
    if (astNode.value) {
      return `return ${astNode.value};`;
    }
    return 'return;';
  }

  generateCallExpression(astNode, context) {
    const args = astNode.arguments.map(arg => {
      if (typeof arg === 'object' && arg.type) {
        // This would need to be generated by other generators
        return arg.name || arg.value || '';
      }
      return arg;
    }).join(', ');

    return `${astNode.function_name}(${args})`;
  }
}